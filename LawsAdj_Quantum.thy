(*
 * This is an autogenerated file. Do not edit.
 * The original is LawsAdj.thy. It was converted using instantiate_laws.py.
 *)

theory LawsAdj_Quantum
imports AxiomsAdj_Quantum Laws_Quantum
begin

notation timesOp (infixl "*\<^sub>u" 55)
notation tensor_op (infixr "\<otimes>\<^sub>u" 70)
notation timesOp (infixl "*\<^sub>u" 55)

declare upd_adjoint_id[simp]
declare upd_adjoint_involution[simp]

lemma update_hom_sandwich[simp]: \<open>clinear (sandwich a)\<close>
  unfolding sandwich_def 
  apply (rule update_comp_hom_is_hom)
  apply (rule hom_comp_update_is_hom)
  sorry

lemma sandwich_id[simp]: "sandwich idOp = id"
  unfolding sandwich_def by auto

lemma sandwich_lvalue[simp]:
  fixes a :: \<open>('a::finite, 'b::finite) update_nonsquare\<close>
  assumes \<open>unitary a\<close>
  shows \<open>lvalue (sandwich a)\<close>
proof -
  note assms update_hom_sandwich
  moreover have \<open>sandwich a idOp = idOp\<close>
    using assms by (auto simp: sandwich_def unitary_update_def)
  moreover have \<open>sandwich a (x *\<^sub>u y) = sandwich a x *\<^sub>u sandwich a y\<close> for x y
    using assms apply (auto simp: sandwich_def unitary_update_def)
    by (metis (no_types, lifting) cblinfun_apply_assoc times_idOp2)
  moreover have \<open>sandwich a (adjoint x) = adjoint (sandwich a x)\<close> for x
    apply (auto simp: sandwich_def unitary_update_def upd_adjoint_comp)
    by (simp add: cblinfun_apply_assoc)
  ultimately show ?thesis
    apply (rule_tac lvalue_sandwhich_axiom)
    by assumption+
qed

end
